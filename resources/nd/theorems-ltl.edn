; Generated by lwb rev 2.1.2 at 2019-12-22
; Do not edit.
{:id :notnot-i, :given [(at [i] P)], :conclusion [(at [i] (not (not P)))], :proof [{:plid 1, :roth :premise, :body (at [i] P)} [{:plid 4, :body (at [i] (not P)), :roth :assumption, :refs nil} {:plid 7, :body (at [i] contradiction), :roth :not-e, :refs [4 1]}] {:plid 2, :body (at [i] (not (not P))), :roth :not-i, :refs [[4 7]]}]}
{:id :always-notnot-i, :given [(at [i] (always P))], :conclusion [(at [i] (always (not (not P))))], :proof [{:plid 1, :roth :premise, :body (at [i] (always P))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 7, :body (at [j] P), :roth :always-e, :refs [1 4]} {:plid 8, :body (at [j] (not (not P))), :roth :notnot-i, :refs [7]}] {:plid 2, :body (at [i] (always (not (not P)))), :roth :always-i, :refs [[4 8]]}]}
{:id :notnot-e, :given [(at [i] (not (not P)))], :conclusion [(at [i] P)], :proof [{:plid 1, :roth :premise, :body (at [i] (not (not P)))} [{:plid 4, :body (at [i] (not P)), :roth :assumption, :refs nil} {:plid 7, :body (at [i] contradiction), :roth :not-e, :refs [1 4]}] {:plid 2, :body (at [i] P), :roth :raa, :refs [[4 7]]}]}
{:id :always-notnot-e, :given [(at [i] (always (not (not A))))], :conclusion [(at [i] (always A))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (not (not A))))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 7, :body (at [j] (not (not A))), :roth :always-e, :refs [1 4]} {:plid 8, :body (at [j] A), :roth :notnot-e, :refs [7]}] {:plid 2, :body (at [i] (always A)), :roth :always-i, :refs [[4 8]]}]}
{:id :mt, :given [(at [i] (impl P Q)) (at [i] (not Q))], :conclusion [(at [i] (not P))], :proof [{:plid 1, :roth :premise, :body (at [i] (impl P Q))} {:plid 2, :roth :premise, :body (at [i] (not Q))} [{:plid 5, :body (at [i] P), :roth :assumption, :refs nil} {:plid 8, :body (at [i] Q), :roth :impl-e, :refs [1 5]} {:plid 9, :body (at [i] contradiction), :roth :not-e, :refs [2 8]}] {:plid 3, :body (at [i] (not P)), :roth :not-i, :refs [[5 9]]}]}
{:id :tnd, :given [], :conclusion [(at [i] (or P (not P)))], :proof [[{:plid 3, :body (at [i] (not (or P (not P)))), :roth :assumption, :refs nil} [{:plid 8, :body (at [i] P), :roth :assumption, :refs nil} {:plid 11, :body (at [i] (or P (not P))), :roth :or-i1, :refs [8]} {:plid 10, :body (at [i] contradiction), :roth :not-e, :refs [3 11]}] {:plid 7, :body (at [i] (not P)), :roth :not-i, :refs [[8 10]]} {:plid 6, :body (at [i] (or P (not P))), :roth :or-i2, :refs [7]} {:plid 5, :body (at [i] contradiction), :roth :not-e, :refs [3 6]}] {:plid 1, :body (at [i] (or P (not P))), :roth :raa, :refs [[3 5]]}]}
{:id :always-tnd, :given [], :conclusion [(at [i] (always (or P (not P))))], :proof [[{:plid 3, :body (<= i j), :roth :assumption, :refs nil} {:plid 6, :body (at [j] (or P (not P))), :roth :tnd, :refs []}] {:plid 1, :body (at [i] (always (or P (not P)))), :roth :always-i, :refs [[3 6]]}]}
{:id :contrap, :given [(at [i] (impl A B))], :conclusion [(at [i] (impl (not B) (not A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (impl A B))} [{:plid 4, :body (at [i] (not B)), :roth :assumption, :refs nil} [{:plid 7, :body (at [i] A), :roth :assumption, :refs nil} {:plid 10, :body (at [i] B), :roth :impl-e, :refs [1 7]} {:plid 9, :body (at [i] contradiction), :roth :not-e, :refs [4 10]}] {:plid 6, :body (at [i] (not A)), :roth :not-i, :refs [[7 9]]}] {:plid 2, :body (at [i] (impl (not B) (not A))), :roth :impl-i, :refs [[4 6]]}]}
{:id :not-and->or-not, :given [(at [i] (not (and P Q)))], :conclusion [(at [i] (or (not P) (not Q)))], :proof [{:plid 1, :roth :premise, :body (at [i] (not (and P Q)))} [{:plid 4, :body (at [i] (not (or (not P) (not Q)))), :roth :assumption, :refs nil} [{:plid 20, :body (at [i] (not P)), :roth :assumption, :refs nil} {:plid 24, :body (at [i] (or (not P) (not Q))), :roth :or-i1, :refs [20]} {:plid 22, :body (at [i] contradiction), :roth :not-e, :refs [4 24]}] {:plid 10, :body (at [i] P), :roth :raa, :refs [[20 22]]} [{:plid 13, :body (at [i] (not Q)), :roth :assumption, :refs nil} {:plid 17, :body (at [i] (or (not P) (not Q))), :roth :or-i2, :refs [13]} {:plid 15, :body (at [i] contradiction), :roth :not-e, :refs [4 17]}] {:plid 11, :body (at [i] Q), :roth :raa, :refs [[13 15]]} {:plid 8, :body (at [i] (and P Q)), :roth :and-i, :refs [10 11]} {:plid 6, :body (at [i] contradiction), :roth :not-e, :refs [1 8]}] {:plid 2, :body (at [i] (or (not P) (not Q))), :roth :raa, :refs [[4 6]]}]}
{:id :or-not->not-and, :given [(at [i] (or (not P) (not Q)))], :conclusion [(at [i] (not (and P Q)))], :proof [{:plid 1, :roth :premise, :body (at [i] (or (not P) (not Q)))} [{:plid 4, :body (at [i] (not P)), :roth :assumption, :refs nil} [{:plid 10, :body (at [i] (and P Q)), :roth :assumption, :refs nil} {:plid 13, :body (at [i] P), :roth :and-e1, :refs [10]} {:plid 14, :body (at [i] contradiction), :roth :not-e, :refs [4 13]}] {:plid 6, :body (at [i] (not (and P Q))), :roth :not-i, :refs [[10 14]]}] [{:plid 7, :body (at [i] (not Q)), :roth :assumption, :refs nil} [{:plid 15, :body (at [i] (and P Q)), :roth :assumption, :refs nil} {:plid 18, :body (at [i] Q), :roth :and-e2, :refs [15]} {:plid 19, :body (at [i] contradiction), :roth :not-e, :refs [7 18]}] {:plid 9, :body (at [i] (not (and P Q))), :roth :not-i, :refs [[15 19]]}] {:plid 2, :body (at [i] (not (and P Q))), :roth :or-e, :refs [1 [4 6] [7 9]]}]}
{:id :not-or->and-not, :given [(at [i] (not (or P Q)))], :conclusion [(at [i] (and (not P) (not Q)))], :proof [{:plid 1, :roth :premise, :body (at [i] (not (or P Q)))} [{:plid 7, :body (at [i] P), :roth :assumption, :refs nil} {:plid 10, :body (at [i] (or P Q)), :roth :or-i1, :refs [7]} {:plid 11, :body (at [i] contradiction), :roth :not-e, :refs [1 10]}] {:plid 4, :body (at [i] (not P)), :roth :not-i, :refs [[7 11]]} [{:plid 12, :body (at [i] Q), :roth :assumption, :refs nil} {:plid 15, :body (at [i] (or P Q)), :roth :or-i2, :refs [12]} {:plid 16, :body (at [i] contradiction), :roth :not-e, :refs [1 15]}] {:plid 5, :body (at [i] (not Q)), :roth :not-i, :refs [[12 16]]} {:plid 2, :body (at [i] (and (not P) (not Q))), :roth :and-i, :refs [4 5]}]}
{:id :and-not->not-or, :given [(at [i] (and (not P) (not Q)))], :conclusion [(at [i] (not (or P Q)))], :proof [{:plid 1, :roth :premise, :body (at [i] (and (not P) (not Q)))} {:plid 4, :body (at [i] (not P)), :roth :and-e1, :refs [1]} {:plid 5, :body (at [i] (not Q)), :roth :and-e2, :refs [1]} [{:plid 6, :body (at [i] (or P Q)), :roth :assumption, :refs nil} [{:plid 9, :body (at [i] P), :roth :assumption, :refs nil} {:plid 15, :body (at [i] contradiction), :roth :not-e, :refs [4 9]}] [{:plid 12, :body (at [i] Q), :roth :assumption, :refs nil} {:plid 16, :body (at [i] contradiction), :roth :not-e, :refs [5 12]}] {:plid 8, :body (at [i] contradiction), :roth :or-e, :refs [6 [9 15] [12 16]]}] {:plid 2, :body (at [i] (not (or P Q))), :roth :not-i, :refs [[6 8]]}]}
{:id :impl->or-not, :given [(at [i] (impl P Q))], :conclusion [(at [i] (or (not P) Q))], :proof [{:plid 1, :roth :premise, :body (at [i] (impl P Q))} [{:plid 4, :body (at [i] (not (or (not P) Q))), :roth :assumption, :refs nil} {:plid 7, :body (at [i] (and (not (not P)) (not Q))), :roth :not-or->and-not, :refs [4]} {:plid 8, :body (at [i] (not (not P))), :roth :and-e1, :refs [7]} {:plid 9, :body (at [i] P), :roth :notnot-e, :refs [8]} {:plid 10, :body (at [i] Q), :roth :impl-e, :refs [1 9]} {:plid 11, :body (at [i] (not Q)), :roth :and-e2, :refs [7]} {:plid 12, :body (at [i] contradiction), :roth :not-e, :refs [11 10]}] {:plid 2, :body (at [i] (or (not P) Q)), :roth :raa, :refs [[4 12]]}]}
{:id :or-not->impl, :given [(at [i] (or (not P) Q))], :conclusion [(at [i] (impl P Q))], :proof [{:plid 1, :roth :premise, :body (at [i] (or (not P) Q))} [{:plid 4, :body (at [i] (not P)), :roth :assumption, :refs nil} [{:plid 10, :body (at [i] P), :roth :assumption, :refs nil} {:plid 13, :body (at [i] contradiction), :roth :not-e, :refs [4 10]} {:plid 12, :body (at [i] Q), :roth :efq, :refs [13]}] {:plid 6, :body (at [i] (impl P Q)), :roth :impl-i, :refs [[10 12]]}] [{:plid 7, :body (at [i] Q), :roth :assumption, :refs nil} [{:plid 15, :body (at [i] P), :roth :assumption, :refs nil} {:plid 17, :body (at [i] Q), :roth :repeat, :refs [7]}] {:plid 9, :body (at [i] (impl P Q)), :roth :impl-i, :refs [[15 17]]}] {:plid 2, :body (at [i] (impl P Q)), :roth :or-e, :refs [1 [4 6] [7 9]]}]}
{:id :not-atnext->atnext-not, :given [(at [i] (not (atnext A)))], :conclusion [(at [i] (atnext (not A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (not (atnext A)))} {:plid 4, :body (succ i i'), :roth :succ, :refs []} [{:plid 6, :body (at [i'] A), :roth :assumption, :refs nil} {:plid 9, :body (at [i] (atnext A)), :roth :atnext-i, :refs [6 4]} {:plid 10, :body (at [i'] contradiction), :roth :not-e, :refs [1 9]}] {:plid 5, :body (at [i'] (not A)), :roth :not-i, :refs [[6 10]]} {:plid 2, :body (at [i] (atnext (not A))), :roth :atnext-i, :refs [5 4]}]}
{:id :atnext-not->not-atnext, :given [(at [i] (atnext (not A)))], :conclusion [(at [i] (not (atnext A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext (not A)))} [{:plid 4, :body (succ i i'), :roth :assumption, :refs nil} {:plid 5, :body (at [i'] (not A)), :roth :assumption, :refs nil} [{:plid 8, :body (at [i] (atnext A)), :roth :assumption, :refs nil} [{:plid 11, :body (succ i i'), :roth :assumption, :refs nil} {:plid 12, :body (at [i'] A), :roth :assumption, :refs nil} {:plid 15, :body (at [i'] contradiction), :roth :not-e, :refs [5 12]}] {:plid 10, :body (at [i'] contradiction), :roth :atnext-e, :refs [8 [11 15]]}] {:plid 7, :body (at [i] (not (atnext A))), :roth :not-i, :refs [[8 10]]}] {:plid 2, :body (at [i] (not (atnext A))), :roth :atnext-e, :refs [1 [4 7]]}]}
{:id :not-finally->always-not, :given [(at [i] (not (finally A)))], :conclusion [(at [i] (always (not A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (not (finally A)))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} [{:plid 7, :body (at [j] A), :roth :assumption, :refs nil} {:plid 10, :body (at [i] (finally A)), :roth :finally-i, :refs [7 4]} {:plid 9, :body (at [i] contradiction), :roth :not-e, :refs [1 10]}] {:plid 6, :body (at [j] (not A)), :roth :not-i, :refs [[7 9]]}] {:plid 2, :body (at [i] (always (not A))), :roth :always-i, :refs [[4 6]]}]}
{:id :always-not->not-finally, :given [(at [i] (always (not A)))], :conclusion [(at [i] (not (finally A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (not A)))} [{:plid 4, :body (at [i] (finally A)), :roth :assumption, :refs nil} [{:plid 7, :body (<= i j), :roth :assumption, :refs nil} {:plid 8, :body (at [j] A), :roth :assumption, :refs nil} {:plid 11, :body (at [j] (not A)), :roth :always-e, :refs [1 7]} {:plid 12, :body (at [j] contradiction), :roth :not-e, :refs [11 8]}] {:plid 6, :body (at [j] contradiction), :roth :finally-e, :refs [4 [7 12]]}] {:plid 2, :body (at [i] (not (finally A))), :roth :not-i, :refs [[4 6]]}]}
{:id :finally-not->not-always, :given [(at [i] (finally (not A)))], :conclusion [(at [i] (not (always A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (finally (not A)))} [{:plid 4, :body (at [i] (always A)), :roth :assumption, :refs nil} [{:plid 7, :body (<= i j), :roth :assumption, :refs nil} {:plid 8, :body (at [j] (not A)), :roth :assumption, :refs nil} {:plid 11, :body (at [j] A), :roth :always-e, :refs [4 7]} {:plid 10, :body (at [j] contradiction), :roth :not-e, :refs [8 11]}] {:plid 6, :body (at [j] contradiction), :roth :finally-e, :refs [1 [7 10]]}] {:plid 2, :body (at [i] (not (always A))), :roth :not-i, :refs [[4 6]]}]}
{:id :not-always->finally-not, :given [(at [i] (not (always A)))], :conclusion [(at [i] (finally (not A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (not (always A)))} [{:plid 4, :body (at [i] (not (finally (not A)))), :roth :assumption, :refs nil} {:plid 7, :body (at [i] (always (not (not A)))), :roth :not-finally->always-not, :refs [4]} {:plid 8, :body (at [i] (always A)), :roth :always-notnot-e, :refs [7]} {:plid 9, :body (at [i] contradiction), :roth :not-e, :refs [1 8]}] {:plid 2, :body (at [i] (finally (not A))), :roth :raa, :refs [[4 9]]}]}
{:id :always->current, :given [(at [i] (always A))], :conclusion [(at [i] A)], :proof [{:plid 1, :roth :premise, :body (at [i] (always A))} {:plid 4, :body (<= i i), :roth :<=refl, :refs []} {:plid 5, :body (at [i] A), :roth :always-e, :refs [1 4]}]}
{:id :current->finally, :given [(at [i] A)], :conclusion [(at [i] (finally A))], :proof [{:plid 1, :roth :premise, :body (at [i] A)} {:plid 4, :body (<= i i), :roth :<=refl, :refs []} {:plid 2, :body (at [i] (finally A)), :roth :finally-i, :refs [1 4]}]}
{:id :always->atnext, :given [(at [i] (always A))], :conclusion [(at [i] (atnext A))], :proof [{:plid 1, :roth :premise, :body (at [i] (always A))} {:plid 4, :body (succ i i'), :roth :succ, :refs []} {:plid 5, :body (<= i i'), :roth :succ/<=, :refs [4]} {:plid 6, :body (at [i'] A), :roth :always-e, :refs [1 5]} {:plid 2, :body (at [i] (atnext A)), :roth :atnext-i, :refs [6 4]}]}
{:id :atnext->finally, :given [(at [i] (atnext A))], :conclusion [(at [i] (finally A))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext A))} [{:plid 4, :body (succ i i'), :roth :assumption, :refs nil} {:plid 5, :body (at [i'] A), :roth :assumption, :refs nil} {:plid 8, :body (<= i i'), :roth :succ/<=, :refs [4]} {:plid 9, :body (at [i] (finally A)), :roth :finally-i, :refs [5 8]}] {:plid 2, :body (at [i] (finally A)), :roth :atnext-e, :refs [1 [4 9]]}]}
{:id :always->finally, :given [(at [i] (always A))], :conclusion [(at [i] (finally A))], :proof [{:plid 1, :roth :premise, :body (at [i] (always A))} {:plid 4, :body (<= i i), :roth :<=refl, :refs []} {:plid 5, :body (at [i] A), :roth :always-e, :refs [1 4]} {:plid 2, :body (at [i] (finally A)), :roth :finally-i, :refs [5 4]}]}
{:id :finally-always->always-finally, :given [(at [i] (finally (always A)))], :conclusion [(at [i] (always (finally A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (finally (always A)))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} [{:plid 7, :body (<= i k), :roth :assumption, :refs nil} {:plid 8, :body (at [k] (always A)), :roth :assumption, :refs nil} {:plid 11, :body (or (<= j k) (= j k) (<= k j)), :roth :<=linear, :refs [4 7]} [{:plid 12, :body (<= j k), :roth :assumption, :refs nil} {:plid 21, :body (at [k] A), :roth :always->current, :refs [8]} {:plid 14, :body (at [j] (finally A)), :roth :finally-i, :refs [21 12]}] [{:plid 15, :body (= j k), :roth :assumption, :refs nil} {:plid 23, :body (<= j k), :roth :=/<=, :refs [15]} {:plid 24, :body (at [k] A), :roth :always->current, :refs [8]} {:plid 17, :body (at [j] (finally A)), :roth :finally-i, :refs [24 23]}] [{:plid 18, :body (<= k j), :roth :assumption, :refs nil} {:plid 26, :body (at [j] A), :roth :always-e, :refs [8 18]} {:plid 27, :body (<= j j), :roth :<=refl, :refs []} {:plid 20, :body (at [j] (finally A)), :roth :finally-i, :refs [26 27]}] {:plid 10, :body (at [j] (finally A)), :roth :rel-cases, :refs [11 [12 14] [15 17] [18 20]]}] {:plid 6, :body (at [j] (finally A)), :roth :finally-e, :refs [1 [7 10]]}] {:plid 2, :body (at [i] (always (finally A))), :roth :always-i, :refs [[4 6]]}]}
{:id :always-always->always, :given [(at [i] (always (always A)))], :conclusion [(at [i] (always A))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (always A)))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 7, :body (at [j] (always A)), :roth :always-e, :refs [1 4]} {:plid 8, :body (<= j j), :roth :<=refl, :refs []} {:plid 9, :body (at [j] A), :roth :always-e, :refs [7 8]}] {:plid 2, :body (at [i] (always A)), :roth :always-i, :refs [[4 9]]}]}
{:id :always->always-always, :given [(at [i] (always A))], :conclusion [(at [i] (always (always A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (always A))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} [{:plid 7, :body (<= j k), :roth :assumption, :refs nil} {:plid 10, :body (<= i k), :roth :<=trans, :refs [4 7]} {:plid 11, :body (at [k] A), :roth :always-e, :refs [1 10]}] {:plid 6, :body (at [j] (always A)), :roth :always-i, :refs [[7 11]]}] {:plid 2, :body (at [i] (always (always A))), :roth :always-i, :refs [[4 6]]}]}
{:id :finally-finally->finally, :given [(at [i] (finally (finally A)))], :conclusion [(at [i] (finally A))], :proof [{:plid 1, :roth :premise, :body (at [i] (finally (finally A)))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 5, :body (at [j] (finally A)), :roth :assumption, :refs nil} [{:plid 8, :body (<= j k), :roth :assumption, :refs nil} {:plid 9, :body (at [k] A), :roth :assumption, :refs nil} {:plid 12, :body (<= i k), :roth :<=trans, :refs [4 8]} {:plid 13, :body (at [i] (finally A)), :roth :finally-i, :refs [9 12]}] {:plid 7, :body (at [i] (finally A)), :roth :finally-e, :refs [5 [8 13]]}] {:plid 2, :body (at [i] (finally A)), :roth :finally-e, :refs [1 [4 7]]}]}
{:id :finally->finally-finally, :given [(at [i] (finally A))], :conclusion [(at [i] (finally (finally A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (finally A))} {:plid 4, :body (<= i i), :roth :<=refl, :refs []} {:plid 2, :body (at [i] (finally (finally A))), :roth :finally-i, :refs [1 4]}]}
{:id :always-serial, :given [(at [i] (always A))], :conclusion [(at [i] (and A (atnext (always A))))], :proof [{:plid 1, :roth :premise, :body (at [i] (always A))} {:plid 4, :body (at [i] A), :roth :always->current, :refs [1]} {:plid 5, :body (succ i i'), :roth :succ, :refs []} [{:plid 8, :body (<= i' j), :roth :assumption, :refs nil} {:plid 11, :body (<= i i'), :roth :succ/<=, :refs [5]} {:plid 12, :body (<= i j), :roth :<=trans, :refs [11 8]} {:plid 13, :body (at [j] A), :roth :always-e, :refs [1 12]}] {:plid 7, :body (at [i'] (always A)), :roth :always-i, :refs [[8 13]]} {:plid 6, :body (at [i] (atnext (always A))), :roth :atnext-i, :refs [7 5]} {:plid 2, :body (at [i] (and A (atnext (always A)))), :roth :and-i, :refs [4 6]}]}
{:id :always-inductive, :given [(at [i] (and A (always (impl A (atnext A)))))], :conclusion [(at [i] (always A))], :proof [{:plid 1, :roth :premise, :body (at [i] (and A (always (impl A (atnext A)))))} {:plid 4, :body (at [i] A), :roth :and-e1, :refs [1]} {:plid 5, :body (at [i] (always (impl A (atnext A)))), :roth :and-e2, :refs [1]} [{:plid 7, :body (<= i j), :roth :assumption, :refs nil} {:plid 8, :body (succ j j'), :roth :assumption, :refs nil} {:plid 9, :body (at [j] A), :roth :assumption, :refs nil} {:plid 12, :body (at [j] (impl A (atnext A))), :roth :always-e, :refs [5 7]} {:plid 13, :body (at [j] (atnext A)), :roth :impl-e, :refs [12 9]} [{:plid 14, :body (succ j j'), :roth :assumption, :refs nil} {:plid 15, :body (at [j'] A), :roth :assumption, :refs nil} {:plid 17, :body (at [j'] A), :roth :repeat, :refs [15]}] {:plid 11, :body (at [j'] A), :roth :atnext-e, :refs [13 [14 17]]}] {:plid 2, :body (at [i] (always A)), :roth :induction, :refs [4 [7 11]]}]}
{:id :always-atnext->atnext-always, :given [(at [i] (always (atnext A)))], :conclusion [(at [i] (atnext (always A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (atnext A)))} {:plid 4, :body (at [i] (atnext A)), :roth :always->current, :refs [1]} [{:plid 5, :body (succ i i'), :roth :assumption, :refs nil} {:plid 6, :body (at [i'] A), :roth :assumption, :refs nil} [{:plid 12, :body (<= i' j), :roth :assumption, :refs nil} [{:plid 15, :body (at [j] A), :roth :assumption, :refs nil} {:plid 18, :body (<= i i'), :roth :succ/<=, :refs [5]} {:plid 19, :body (<= i j), :roth :<=trans, :refs [18 12]} {:plid 20, :body (at [j] (atnext A)), :roth :always-e, :refs [1 19]}] {:plid 14, :body (at [j] (impl A (atnext A))), :roth :impl-i, :refs [[15 20]]}] {:plid 11, :body (at [i'] (always (impl A (atnext A)))), :roth :always-i, :refs [[12 14]]} {:plid 10, :body (at [i'] (and A (always (impl A (atnext A))))), :roth :and-i, :refs [6 11]} {:plid 9, :body (at [i'] (always A)), :roth :always-inductive, :refs [10]} {:plid 8, :body (at [i] (atnext (always A))), :roth :atnext-i, :refs [9 5]}] {:plid 2, :body (at [i] (atnext (always A))), :roth :atnext-e, :refs [4 [5 8]]}]}
{:id :atnext-always->always-atnext, :given [(at [i] (atnext (always A)))], :conclusion [(at [i] (always (atnext A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext (always A)))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 7, :body (succ j j'), :roth :succ, :refs []} [{:plid 9, :body (succ i i'), :roth :assumption, :refs nil} {:plid 10, :body (at [i'] (always A)), :roth :assumption, :refs nil} {:plid 13, :body (<= i' j'), :roth :<=succsucc/<=, :refs [4 9 7]} {:plid 14, :body (at [j'] A), :roth :always-e, :refs [10 13]}] {:plid 8, :body (at [j'] A), :roth :atnext-e, :refs [1 [9 14]]} {:plid 6, :body (at [j] (atnext A)), :roth :atnext-i, :refs [8 7]}] {:plid 2, :body (at [i] (always (atnext A))), :roth :always-i, :refs [[4 6]]}]}
{:id :finally-atnext->atnext-finally, :given [(at [i] (finally (atnext A)))], :conclusion [(at [i] (atnext (finally A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (finally (atnext A)))} {:plid 4, :body (succ i i'), :roth :succ, :refs []} [{:plid 6, :body (<= i j), :roth :assumption, :refs nil} {:plid 7, :body (at [j] (atnext A)), :roth :assumption, :refs nil} [{:plid 10, :body (succ j j'), :roth :assumption, :refs nil} {:plid 11, :body (at [j'] A), :roth :assumption, :refs nil} {:plid 14, :body (<= i' j'), :roth :<=succsucc/<=, :refs [6 4 10]} {:plid 15, :body (at [i'] (finally A)), :roth :finally-i, :refs [11 14]}] {:plid 9, :body (at [i'] (finally A)), :roth :atnext-e, :refs [7 [10 15]]}] {:plid 5, :body (at [i'] (finally A)), :roth :finally-e, :refs [1 [6 9]]} {:plid 2, :body (at [i] (atnext (finally A))), :roth :atnext-i, :refs [5 4]}]}
{:id :atnext-finally->finally-atnext, :given [(at [i] (atnext (finally A)))], :conclusion [(at [i] (finally (atnext A)))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext (finally A)))} [{:plid 4, :body (succ i i'), :roth :assumption, :refs nil} {:plid 5, :body (at [i'] (finally A)), :roth :assumption, :refs nil} [{:plid 8, :body (<= i' j'), :roth :assumption, :refs nil} {:plid 9, :body (at [j'] A), :roth :assumption, :refs nil} {:plid 12, :body (succ j j'), :roth :succ, :refs []} {:plid 13, :body (at [j] (atnext A)), :roth :atnext-i, :refs [9 12]} {:plid 14, :body (<= i j), :roth :succsucc<=/<=, :refs [4 12 8]} {:plid 15, :body (at [i] (finally (atnext A))), :roth :finally-i, :refs [13 14]}] {:plid 7, :body (at [i] (finally (atnext A))), :roth :finally-e, :refs [5 [8 15]]}] {:plid 2, :body (at [i] (finally (atnext A))), :roth :atnext-e, :refs [1 [4 7]]}]}
{:id :atnext-impl-dist1, :given [(at [i] (atnext (impl A B)))], :conclusion [(at [i] (impl (atnext A) (atnext B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext (impl A B)))} [{:plid 4, :body (at [i] (atnext A)), :roth :assumption, :refs nil} [{:plid 7, :body (succ i i'), :roth :assumption, :refs nil} {:plid 8, :body (at [i'] (impl A B)), :roth :assumption, :refs nil} [{:plid 11, :body (succ i i'), :roth :assumption, :refs nil} {:plid 12, :body (at [i'] A), :roth :assumption, :refs nil} {:plid 15, :body (at [i'] B), :roth :impl-e, :refs [8 12]} {:plid 14, :body (at [i] (atnext B)), :roth :atnext-i, :refs [15 11]}] {:plid 10, :body (at [i] (atnext B)), :roth :atnext-e, :refs [4 [11 14]]}] {:plid 6, :body (at [i] (atnext B)), :roth :atnext-e, :refs [1 [7 10]]}] {:plid 2, :body (at [i] (impl (atnext A) (atnext B))), :roth :impl-i, :refs [[4 6]]}]}
{:id :atnext-impl-dist2, :given [(at [i] (impl (atnext A) (atnext B)))], :conclusion [(at [i] (atnext (impl A B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (impl (atnext A) (atnext B)))} {:plid 4, :body (succ i i'), :roth :succ, :refs []} [{:plid 6, :body (at [i'] A), :roth :assumption, :refs nil} {:plid 9, :body (at [i] (atnext A)), :roth :atnext-i, :refs [6 4]} {:plid 10, :body (at [i] (atnext B)), :roth :impl-e, :refs [1 9]} [{:plid 11, :body (succ i i'), :roth :assumption, :refs nil} {:plid 12, :body (at [i'] B), :roth :assumption, :refs nil} {:plid 14, :body (at [i'] B), :roth :repeat, :refs [12]}] {:plid 8, :body (at [i'] B), :roth :atnext-e, :refs [10 [11 14]]}] {:plid 5, :body (at [i'] (impl A B)), :roth :impl-i, :refs [[6 8]]} {:plid 2, :body (at [i] (atnext (impl A B))), :roth :atnext-i, :refs [5 4]}]}
{:id :atnext-and-dist1, :given [(at [i] (atnext (and A B)))], :conclusion [(at [i] (and (atnext A) (atnext B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext (and A B)))} [{:plid 4, :body (succ i i'), :roth :assumption, :refs nil} {:plid 5, :body (at [i'] (and A B)), :roth :assumption, :refs nil} {:plid 8, :body (at [i'] A), :roth :and-e1, :refs [5]} {:plid 9, :body (at [i'] B), :roth :and-e2, :refs [5]} {:plid 10, :body (at [i] (atnext A)), :roth :atnext-i, :refs [8 4]} {:plid 11, :body (at [i] (atnext B)), :roth :atnext-i, :refs [9 4]} {:plid 7, :body (at [i] (and (atnext A) (atnext B))), :roth :and-i, :refs [10 11]}] {:plid 2, :body (at [i] (and (atnext A) (atnext B))), :roth :atnext-e, :refs [1 [4 7]]}]}
{:id :atnext-and-dist2, :given [(at [i] (and (atnext A) (atnext B)))], :conclusion [(at [i] (atnext (and A B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (and (atnext A) (atnext B)))} {:plid 4, :body (at [i] (atnext A)), :roth :and-e1, :refs [1]} [{:plid 5, :body (succ i i'), :roth :assumption, :refs nil} {:plid 6, :body (at [i'] A), :roth :assumption, :refs nil} {:plid 9, :body (at [i] (atnext B)), :roth :and-e2, :refs [1]} [{:plid 10, :body (succ i i'), :roth :assumption, :refs nil} {:plid 11, :body (at [i'] B), :roth :assumption, :refs nil} {:plid 14, :body (at [i'] (and A B)), :roth :and-i, :refs [6 11]} {:plid 13, :body (at [i] (atnext (and A B))), :roth :atnext-i, :refs [14 10]}] {:plid 8, :body (at [i] (atnext (and A B))), :roth :atnext-e, :refs [9 [10 13]]}] {:plid 2, :body (at [i] (atnext (and A B))), :roth :atnext-e, :refs [4 [5 8]]}]}
{:id :atnext-or-dist1, :given [(at [i] (atnext (or A B)))], :conclusion [(at [i] (or (atnext A) (atnext B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext (or A B)))} [{:plid 4, :body (succ i i'), :roth :assumption, :refs nil} {:plid 5, :body (at [i'] (or A B)), :roth :assumption, :refs nil} [{:plid 8, :body (at [i] (not (or (atnext A) (atnext B)))), :roth :assumption, :refs nil} {:plid 11, :body (at [i] (and (not (atnext A)) (not (atnext B)))), :roth :not-or->and-not, :refs [8]} {:plid 12, :body (at [i] (not (atnext A))), :roth :and-e1, :refs [11]} {:plid 13, :body (at [i] (not (atnext B))), :roth :and-e2, :refs [11]} {:plid 14, :body (at [i] (atnext (not A))), :roth :not-atnext->atnext-not, :refs [12]} {:plid 15, :body (at [i] (atnext (not B))), :roth :not-atnext->atnext-not, :refs [13]} [{:plid 16, :body (succ i i'), :roth :assumption, :refs nil} {:plid 17, :body (at [i'] (not A)), :roth :assumption, :refs nil} [{:plid 20, :body (succ i i'), :roth :assumption, :refs nil} {:plid 21, :body (at [i'] (not B)), :roth :assumption, :refs nil} {:plid 24, :body (at [i'] (and (not A) (not B))), :roth :and-i, :refs [17 21]} {:plid 25, :body (at [i'] (not (or A B))), :roth :and-not->not-or, :refs [24]} {:plid 26, :body (at [i'] contradiction), :roth :not-e, :refs [25 5]}] {:plid 19, :body (at [i'] contradiction), :roth :atnext-e, :refs [15 [20 26]]}] {:plid 10, :body (at [i'] contradiction), :roth :atnext-e, :refs [14 [16 19]]}] {:plid 7, :body (at [i] (or (atnext A) (atnext B))), :roth :raa, :refs [[8 10]]}] {:plid 2, :body (at [i] (or (atnext A) (atnext B))), :roth :atnext-e, :refs [1 [4 7]]}]}
{:id :atnext-or-dist2, :given [(at [i] (or (atnext A) (atnext B)))], :conclusion [(at [i] (atnext (or A B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (or (atnext A) (atnext B)))} [{:plid 4, :body (at [i] (atnext A)), :roth :assumption, :refs nil} [{:plid 10, :body (succ i i'), :roth :assumption, :refs nil} {:plid 11, :body (at [i'] A), :roth :assumption, :refs nil} {:plid 14, :body (at [i'] (or A B)), :roth :or-i1, :refs [11]} {:plid 13, :body (at [i] (atnext (or A B))), :roth :atnext-i, :refs [14 10]}] {:plid 6, :body (at [i] (atnext (or A B))), :roth :atnext-e, :refs [4 [10 13]]}] [{:plid 7, :body (at [i] (atnext B)), :roth :assumption, :refs nil} [{:plid 16, :body (succ i i'), :roth :assumption, :refs nil} {:plid 17, :body (at [i'] B), :roth :assumption, :refs nil} {:plid 20, :body (at [i'] (or A B)), :roth :or-i2, :refs [17]} {:plid 19, :body (at [i] (atnext (or A B))), :roth :atnext-i, :refs [20 16]}] {:plid 9, :body (at [i] (atnext (or A B))), :roth :atnext-e, :refs [7 [16 19]]}] {:plid 2, :body (at [i] (atnext (or A B))), :roth :or-e, :refs [1 [4 6] [7 9]]}]}
{:id :always-and-dist1, :given [(at [i] (always (and A B)))], :conclusion [(at [i] (and (always A) (always B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (and A B)))} [{:plid 7, :body (<= i j), :roth :assumption, :refs nil} {:plid 10, :body (at [j] (and A B)), :roth :always-e, :refs [1 7]} {:plid 11, :body (at [j] A), :roth :and-e1, :refs [10]}] {:plid 4, :body (at [i] (always A)), :roth :always-i, :refs [[7 11]]} [{:plid 12, :body (<= i j), :roth :assumption, :refs nil} {:plid 15, :body (at [j] (and A B)), :roth :always-e, :refs [1 12]} {:plid 16, :body (at [j] B), :roth :and-e2, :refs [15]}] {:plid 5, :body (at [i] (always B)), :roth :always-i, :refs [[12 16]]} {:plid 2, :body (at [i] (and (always A) (always B))), :roth :and-i, :refs [4 5]}]}
{:id :always-and-dist2, :given [(at [i] (and (always A) (always B)))], :conclusion [(at [i] (always (and A B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (and (always A) (always B)))} {:plid 4, :body (at [i] (always A)), :roth :and-e1, :refs [1]} {:plid 5, :body (at [i] (always B)), :roth :and-e2, :refs [1]} [{:plid 6, :body (<= i j), :roth :assumption, :refs nil} {:plid 9, :body (at [j] A), :roth :always-e, :refs [4 6]} {:plid 10, :body (at [j] B), :roth :always-e, :refs [5 6]} {:plid 8, :body (at [j] (and A B)), :roth :and-i, :refs [9 10]}] {:plid 2, :body (at [i] (always (and A B))), :roth :always-i, :refs [[6 8]]}]}
{:id :finally-or-dist1, :given [(at [i] (finally (or A B)))], :conclusion [(at [i] (or (finally A) (finally B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (finally (or A B)))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 5, :body (at [j] (or A B)), :roth :assumption, :refs nil} [{:plid 8, :body (at [i] (not (or (finally A) (finally B)))), :roth :assumption, :refs nil} {:plid 11, :body (at [i] (and (not (finally A)) (not (finally B)))), :roth :not-or->and-not, :refs [8]} {:plid 12, :body (at [i] (not (finally A))), :roth :and-e1, :refs [11]} {:plid 13, :body (at [i] (not (finally B))), :roth :and-e2, :refs [11]} {:plid 14, :body (at [i] (always (not A))), :roth :not-finally->always-not, :refs [12]} {:plid 15, :body (at [i] (always (not B))), :roth :not-finally->always-not, :refs [13]} [{:plid 16, :body (at [j] A), :roth :assumption, :refs nil} {:plid 22, :body (at [j] (not A)), :roth :always-e, :refs [14 4]} {:plid 23, :body (at [j] contradiction), :roth :not-e, :refs [22 16]}] [{:plid 19, :body (at [j] B), :roth :assumption, :refs nil} {:plid 24, :body (at [j] (not B)), :roth :always-e, :refs [15 4]} {:plid 21, :body (at [j] contradiction), :roth :not-e, :refs [24 19]}] {:plid 10, :body (at [j] contradiction), :roth :or-e, :refs [5 [16 23] [19 21]]}] {:plid 7, :body (at [i] (or (finally A) (finally B))), :roth :raa, :refs [[8 10]]}] {:plid 2, :body (at [i] (or (finally A) (finally B))), :roth :finally-e, :refs [1 [4 7]]}]}
{:id :finally-or-dist2, :given [(at [i] (or (finally A) (finally B)))], :conclusion [(at [i] (finally (or A B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (or (finally A) (finally B)))} [{:plid 4, :body (at [i] (finally A)), :roth :assumption, :refs nil} [{:plid 10, :body (<= i j), :roth :assumption, :refs nil} {:plid 11, :body (at [j] A), :roth :assumption, :refs nil} {:plid 14, :body (at [j] (or A B)), :roth :or-i1, :refs [11]} {:plid 13, :body (at [i] (finally (or A B))), :roth :finally-i, :refs [14 10]}] {:plid 6, :body (at [i] (finally (or A B))), :roth :finally-e, :refs [4 [10 13]]}] [{:plid 7, :body (at [i] (finally B)), :roth :assumption, :refs nil} [{:plid 16, :body (<= i j), :roth :assumption, :refs nil} {:plid 17, :body (at [j] B), :roth :assumption, :refs nil} {:plid 20, :body (at [j] (or A B)), :roth :or-i2, :refs [17]} {:plid 19, :body (at [i] (finally (or A B))), :roth :finally-i, :refs [20 16]}] {:plid 9, :body (at [i] (finally (or A B))), :roth :finally-e, :refs [7 [16 19]]}] {:plid 2, :body (at [i] (finally (or A B))), :roth :or-e, :refs [1 [4 6] [7 9]]}]}
{:id :finally-always-and-dist1, :given [(at [i] (finally (always (and A B))))], :conclusion [(at [i] (and (finally (always A)) (finally (always B))))], :proof [{:plid 1, :roth :premise, :body (at [i] (finally (always (and A B))))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 5, :body (at [j] (always (and A B))), :roth :assumption, :refs nil} {:plid 8, :body (at [j] (and (always A) (always B))), :roth :always-and-dist1, :refs [5]} {:plid 9, :body (at [j] (always A)), :roth :and-e1, :refs [8]} {:plid 10, :body (at [j] (always B)), :roth :and-e2, :refs [8]} {:plid 14, :body (at [j] (always (always A))), :roth :always->always-always, :refs [9]} {:plid 15, :body (at [j] (always A)), :roth :always->current, :refs [14]} {:plid 16, :body (at [i] (finally (always A))), :roth :finally-i, :refs [15 4]} {:plid 17, :body (at [j] (always (always B))), :roth :always->always-always, :refs [10]} {:plid 18, :body (at [j] (always B)), :roth :always->current, :refs [17]} {:plid 19, :body (at [i] (finally (always B))), :roth :finally-i, :refs [18 4]} {:plid 7, :body (at [i] (and (finally (always A)) (finally (always B)))), :roth :and-i, :refs [16 19]}] {:plid 2, :body (at [i] (and (finally (always A)) (finally (always B)))), :roth :finally-e, :refs [1 [4 7]]}]}
{:id :finally-always-and-dist2, :given [(at [i] (and (finally (always A)) (finally (always B))))], :conclusion [(at [i] (finally (always (and A B))))], :proof [{:plid 1, :roth :premise, :body (at [i] (and (finally (always A)) (finally (always B))))} {:plid 4, :body (at [i] (finally (always A))), :roth :and-e1, :refs [1]} {:plid 5, :body (at [i] (finally (always B))), :roth :and-e2, :refs [1]} [{:plid 6, :body (<= i j), :roth :assumption, :refs nil} {:plid 7, :body (at [j] (always A)), :roth :assumption, :refs nil} {:plid 10, :body (at [j] (always (always A))), :roth :always->always-always, :refs [7]} [{:plid 11, :body (<= i k), :roth :assumption, :refs nil} {:plid 12, :body (at [k] (always B)), :roth :assumption, :refs nil} {:plid 15, :body (at [k] (always (always B))), :roth :always->always-always, :refs [12]} {:plid 16, :body (or (<= j k) (= j k) (<= k j)), :roth :<=linear, :refs [6 11]} [{:plid 17, :body (<= j k), :roth :assumption, :refs nil} {:plid 26, :body (at [k] (always A)), :roth :always-e, :refs [10 17]} {:plid 27, :body (at [k] (and (always A) (always B))), :roth :and-i, :refs [26 12]} {:plid 28, :body (at [k] (always (and A B))), :roth :always-and-dist2, :refs [27]} {:plid 29, :body (<= i k), :roth :<=trans, :refs [6 17]} {:plid 30, :body (at [i] (finally (always (and A B)))), :roth :finally-i, :refs [28 29]}] [{:plid 20, :body (= j k), :roth :assumption, :refs nil} {:plid 31, :body (at [k] (always A)), :roth :=fml, :refs [20 7]} {:plid 32, :body (at [k] (and (always A) (always B))), :roth :and-i, :refs [31 12]} {:plid 33, :body (at [k] (always (and A B))), :roth :always-and-dist2, :refs [32]} {:plid 34, :body (<= j k), :roth :=/<=, :refs [20]} {:plid 35, :body (<= i k), :roth :<=trans, :refs [6 34]} {:plid 36, :body (at [i] (finally (always (and A B)))), :roth :finally-i, :refs [33 35]}] [{:plid 23, :body (<= k j), :roth :assumption, :refs nil} {:plid 37, :body (at [j] (always B)), :roth :always-e, :refs [15 23]} {:plid 38, :body (at [j] (and (always A) (always B))), :roth :and-i, :refs [7 37]} {:plid 39, :body (at [j] (always (and A B))), :roth :always-and-dist2, :refs [38]} {:plid 40, :body (<= i j), :roth :<=trans, :refs [11 23]} {:plid 41, :body (at [i] (finally (always (and A B)))), :roth :finally-i, :refs [39 40]}] {:plid 14, :body (at [i] (finally (always (and A B)))), :roth :rel-cases, :refs [16 [17 30] [20 36] [23 41]]}] {:plid 9, :body (at [i] (finally (always (and A B)))), :roth :finally-e, :refs [5 [11 14]]}] {:plid 2, :body (at [i] (finally (always (and A B)))), :roth :finally-e, :refs [4 [6 9]]}]}
{:id :always-finally-or-dist1, :given [(at [i] (always (finally (or A B))))], :conclusion [(at [i] (or (always (finally A)) (always (finally B))))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (finally (or A B))))} [{:plid 4, :body (at [i] (not (or (always (finally A)) (always (finally B))))), :roth :assumption, :refs nil} {:plid 7, :body (at [i] (and (not (always (finally A))) (not (always (finally B))))), :roth :not-or->and-not, :refs [4]} {:plid 8, :body (at [i] (not (always (finally A)))), :roth :and-e1, :refs [7]} {:plid 9, :body (at [i] (not (always (finally B)))), :roth :and-e2, :refs [7]} {:plid 10, :body (at [i] (finally (not (finally A)))), :roth :not-always->finally-not, :refs [8]} {:plid 11, :body (at [i] (finally (not (finally B)))), :roth :not-always->finally-not, :refs [9]} {:plid 12, :body (at [i] (finally (always (not A)))), :roth :finally-not-finally->finally-always-not, :refs [10]} {:plid 13, :body (at [i] (finally (always (not B)))), :roth :finally-not-finally->finally-always-not, :refs [11]} {:plid 14, :body (at [i] (and (finally (always (not A))) (finally (always (not B))))), :roth :and-i, :refs [12 13]} {:plid 15, :body (at [i] (finally (always (and (not A) (not B))))), :roth :finally-always-and-dist2, :refs [14]} [{:plid 16, :body (<= i j), :roth :assumption, :refs nil} {:plid 17, :body (at [j] (always (and (not A) (not B)))), :roth :assumption, :refs nil} {:plid 20, :body (at [j] (always (not (or A B)))), :roth :always-and-not->always-not-or, :refs [17]} {:plid 21, :body (at [j] (finally (or A B))), :roth :always-e, :refs [1 16]} [{:plid 22, :body (<= j k), :roth :assumption, :refs nil} {:plid 23, :body (at [k] (or A B)), :roth :assumption, :refs nil} {:plid 26, :body (at [k] (not (or A B))), :roth :always-e, :refs [20 22]} {:plid 27, :body (at [k] contradiction), :roth :not-e, :refs [26 23]}] {:plid 19, :body (at [k] contradiction), :roth :finally-e, :refs [21 [22 27]]}] {:plid 6, :body (at [k] contradiction), :roth :finally-e, :refs [15 [16 19]]}] {:plid 2, :body (at [i] (or (always (finally A)) (always (finally B)))), :roth :raa, :refs [[4 6]]}]}
{:id :always-finally-or-dist2, :given [(at [i] (or (always (finally A)) (always (finally B))))], :conclusion [(at [i] (always (finally (or A B))))], :proof [{:plid 1, :roth :premise, :body (at [i] (or (always (finally A)) (always (finally B))))} [{:plid 4, :body (at [i] (always (finally A))), :roth :assumption, :refs nil} [{:plid 10, :body (<= i j), :roth :assumption, :refs nil} {:plid 13, :body (at [j] (finally A)), :roth :always-e, :refs [4 10]} [{:plid 14, :body (<= j k), :roth :assumption, :refs nil} {:plid 15, :body (at [k] A), :roth :assumption, :refs nil} {:plid 18, :body (at [k] (or A B)), :roth :or-i1, :refs [15]} {:plid 19, :body (at [j] (finally (or A B))), :roth :finally-i, :refs [18 14]}] {:plid 12, :body (at [j] (finally (or A B))), :roth :finally-e, :refs [13 [14 19]]}] {:plid 6, :body (at [i] (always (finally (or A B)))), :roth :always-i, :refs [[10 12]]}] [{:plid 7, :body (at [i] (always (finally B))), :roth :assumption, :refs nil} [{:plid 20, :body (<= i j), :roth :assumption, :refs nil} {:plid 23, :body (at [j] (finally B)), :roth :always-e, :refs [7 20]} [{:plid 24, :body (<= j k), :roth :assumption, :refs nil} {:plid 25, :body (at [k] B), :roth :assumption, :refs nil} {:plid 28, :body (at [k] (or A B)), :roth :or-i2, :refs [25]} {:plid 29, :body (at [j] (finally (or A B))), :roth :finally-i, :refs [28 24]}] {:plid 22, :body (at [j] (finally (or A B))), :roth :finally-e, :refs [23 [24 29]]}] {:plid 9, :body (at [i] (always (finally (or A B)))), :roth :always-i, :refs [[20 22]]}] {:plid 2, :body (at [i] (always (finally (or A B)))), :roth :or-e, :refs [1 [4 6] [7 9]]}]}
{:id :always-impl-dist, :given [(at [i] (always (impl A B)))], :conclusion [(at [i] (impl (always A) (always B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (impl A B)))} [{:plid 4, :body (at [i] (always A)), :roth :assumption, :refs nil} [{:plid 7, :body (<= i j), :roth :assumption, :refs nil} {:plid 10, :body (at [j] (impl A B)), :roth :always-e, :refs [1 7]} {:plid 11, :body (at [j] A), :roth :always-e, :refs [4 7]} {:plid 12, :body (at [j] B), :roth :impl-e, :refs [10 11]}] {:plid 6, :body (at [i] (always B)), :roth :always-i, :refs [[7 12]]}] {:plid 2, :body (at [i] (impl (always A) (always B))), :roth :impl-i, :refs [[4 6]]}]}
{:id :always-or-dist, :given [(at [i] (or (always A) (always B)))], :conclusion [(at [i] (always (or A B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (or (always A) (always B)))} [{:plid 4, :body (at [i] (always A)), :roth :assumption, :refs nil} [{:plid 10, :body (<= i j), :roth :assumption, :refs nil} {:plid 13, :body (at [j] A), :roth :always-e, :refs [4 10]} {:plid 14, :body (at [j] (or A B)), :roth :or-i1, :refs [13]}] {:plid 6, :body (at [i] (always (or A B))), :roth :always-i, :refs [[10 14]]}] [{:plid 7, :body (at [i] (always B)), :roth :assumption, :refs nil} [{:plid 15, :body (<= i j), :roth :assumption, :refs nil} {:plid 18, :body (at [j] B), :roth :always-e, :refs [7 15]} {:plid 17, :body (at [j] (or A B)), :roth :or-i2, :refs [18]}] {:plid 9, :body (at [i] (always (or A B))), :roth :always-i, :refs [[15 17]]}] {:plid 2, :body (at [i] (always (or A B))), :roth :or-e, :refs [1 [4 6] [7 9]]}]}
{:id :finally-impl-dist, :given [(at [i] (impl (finally A) (finally B)))], :conclusion [(at [i] (finally (impl A B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (impl (finally A) (finally B)))} {:plid 4, :body (at [i] (or (not (finally A)) (finally B))), :roth :impl->or-not, :refs [1]} [{:plid 5, :body (at [i] (not (finally A))), :roth :assumption, :refs nil} {:plid 11, :body (at [i] (always (not A))), :roth :not-finally->always-not, :refs [5]} {:plid 12, :body (<= i i), :roth :<=refl, :refs []} {:plid 13, :body (at [i] (not A)), :roth :always-e, :refs [11 12]} {:plid 14, :body (at [i] (or (not A) B)), :roth :or-i1, :refs [13]} {:plid 15, :body (at [i] (impl A B)), :roth :or-not->impl, :refs [14]} {:plid 16, :body (at [i] (finally (impl A B))), :roth :finally-i, :refs [15 12]}] [{:plid 8, :body (at [i] (finally B)), :roth :assumption, :refs nil} [{:plid 17, :body (<= i j), :roth :assumption, :refs nil} {:plid 18, :body (at [j] B), :roth :assumption, :refs nil} {:plid 21, :body (at [j] (or (not A) B)), :roth :or-i2, :refs [18]} {:plid 22, :body (at [j] (impl A B)), :roth :or-not->impl, :refs [21]} {:plid 23, :body (at [i] (finally (impl A B))), :roth :finally-i, :refs [22 17]}] {:plid 10, :body (at [i] (finally (impl A B))), :roth :finally-e, :refs [8 [17 23]]}] {:plid 2, :body (at [i] (finally (impl A B))), :roth :or-e, :refs [4 [5 16] [8 10]]}]}
{:id :finally-and-dist, :given [(at [i] (finally (and A B)))], :conclusion [(at [i] (and (finally A) (finally B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (finally (and A B)))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 5, :body (at [j] (and A B)), :roth :assumption, :refs nil} {:plid 8, :body (at [j] A), :roth :and-e1, :refs [5]} {:plid 9, :body (at [j] B), :roth :and-e2, :refs [5]} {:plid 10, :body (at [i] (finally A)), :roth :finally-i, :refs [8 4]} {:plid 11, :body (at [i] (finally B)), :roth :finally-i, :refs [9 4]} {:plid 12, :body (at [i] (and (finally A) (finally B))), :roth :and-i, :refs [10 11]}] {:plid 2, :body (at [i] (and (finally A) (finally B))), :roth :finally-e, :refs [1 [4 12]]}]}
{:id :always-finally-and-dist, :given [(at [i] (always (finally (and A B))))], :conclusion [(at [i] (and (always (finally A)) (always (finally B))))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (finally (and A B))))} [{:plid 7, :body (<= i j), :roth :assumption, :refs nil} {:plid 10, :body (at [j] (finally (and A B))), :roth :always-e, :refs [1 7]} [{:plid 11, :body (<= j k), :roth :assumption, :refs nil} {:plid 12, :body (at [k] (and A B)), :roth :assumption, :refs nil} {:plid 15, :body (at [k] A), :roth :and-e1, :refs [12]} {:plid 16, :body (at [j] (finally A)), :roth :finally-i, :refs [15 11]}] {:plid 9, :body (at [j] (finally A)), :roth :finally-e, :refs [10 [11 16]]}] {:plid 4, :body (at [i] (always (finally A))), :roth :always-i, :refs [[7 9]]} [{:plid 17, :body (<= i j), :roth :assumption, :refs nil} {:plid 20, :body (at [j] (finally (and A B))), :roth :always-e, :refs [1 17]} [{:plid 21, :body (<= j k), :roth :assumption, :refs nil} {:plid 22, :body (at [k] (and A B)), :roth :assumption, :refs nil} {:plid 25, :body (at [k] B), :roth :and-e2, :refs [22]} {:plid 26, :body (at [j] (finally B)), :roth :finally-i, :refs [25 21]}] {:plid 19, :body (at [j] (finally B)), :roth :finally-e, :refs [20 [21 26]]}] {:plid 5, :body (at [i] (always (finally B))), :roth :always-i, :refs [[17 19]]} {:plid 2, :body (at [i] (and (always (finally A)) (always (finally B)))), :roth :and-i, :refs [4 5]}]}
{:id :finally-always-or-dist, :given [(at [i] (or (finally (always A)) (finally (always B))))], :conclusion [(at [i] (finally (always (or A B))))], :proof [{:plid 1, :roth :premise, :body (at [i] (or (finally (always A)) (finally (always B))))} [{:plid 4, :body (at [i] (finally (always A))), :roth :assumption, :refs nil} [{:plid 10, :body (<= i j), :roth :assumption, :refs nil} {:plid 11, :body (at [j] (always A)), :roth :assumption, :refs nil} [{:plid 16, :body (<= j k), :roth :assumption, :refs nil} {:plid 19, :body (at [k] A), :roth :always-e, :refs [11 16]} {:plid 18, :body (at [k] (or A B)), :roth :or-i1, :refs [19]}] {:plid 14, :body (at [j] (always (or A B))), :roth :always-i, :refs [[16 18]]} {:plid 21, :body (at [i] (finally (always (or A B)))), :roth :finally-i, :refs [14 10]}] {:plid 6, :body (at [i] (finally (always (or A B)))), :roth :finally-e, :refs [4 [10 21]]}] [{:plid 7, :body (at [i] (finally (always B))), :roth :assumption, :refs nil} [{:plid 22, :body (<= i j), :roth :assumption, :refs nil} {:plid 23, :body (at [j] (always B)), :roth :assumption, :refs nil} [{:plid 28, :body (<= j k), :roth :assumption, :refs nil} {:plid 31, :body (at [k] B), :roth :always-e, :refs [23 28]} {:plid 30, :body (at [k] (or A B)), :roth :or-i2, :refs [31]}] {:plid 26, :body (at [j] (always (or A B))), :roth :always-i, :refs [[28 30]]} {:plid 33, :body (at [i] (finally (always (or A B)))), :roth :finally-i, :refs [26 22]}] {:plid 9, :body (at [i] (finally (always (or A B)))), :roth :finally-e, :refs [7 [22 33]]}] {:plid 2, :body (at [i] (finally (always (or A B)))), :roth :or-e, :refs [1 [4 6] [7 9]]}]}
{:id :finally-serial, :given [(at [i] (finally A))], :conclusion [(at [i] (or A (atnext (finally A))))], :proof [{:plid 1, :roth :premise, :body (at [i] (finally A))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 5, :body (at [j] A), :roth :assumption, :refs nil} {:plid 8, :body (succ i i'), :roth :succ, :refs []} {:plid 9, :body (or (= i j) (<= i' j)), :roth :succ/<=linear, :refs [8 4]} [{:plid 10, :body (= i j), :roth :assumption, :refs nil} {:plid 16, :body (= j i), :roth :=sym, :refs [10]} {:plid 17, :body (at [i] A), :roth :=fml, :refs [16 5]} {:plid 12, :body (at [i] (or A (atnext (finally A)))), :roth :or-i1, :refs [17]}] [{:plid 13, :body (<= i' j), :roth :assumption, :refs nil} {:plid 21, :body (at [i'] (finally A)), :roth :finally-i, :refs [5 13]} {:plid 19, :body (at [i] (atnext (finally A))), :roth :atnext-i, :refs [21 8]} {:plid 15, :body (at [i] (or A (atnext (finally A)))), :roth :or-i2, :refs [19]}] {:plid 7, :body (at [i] (or A (atnext (finally A)))), :roth :rel-or, :refs [9 [10 12] [13 15]]}] {:plid 2, :body (at [i] (or A (atnext (finally A)))), :roth :finally-e, :refs [1 [4 7]]}]}
{:id :finally-inductive, :given [(at [i] (or A (atnext (finally A))))], :conclusion [(at [i] (finally A))], :proof [{:plid 1, :roth :premise, :body (at [i] (or A (atnext (finally A))))} [{:plid 4, :body (at [i] A), :roth :assumption, :refs nil} {:plid 10, :body (<= i i), :roth :<=refl, :refs []} {:plid 11, :body (at [i] (finally A)), :roth :finally-i, :refs [4 10]}] [{:plid 7, :body (at [i] (atnext (finally A))), :roth :assumption, :refs nil} [{:plid 12, :body (succ i i'), :roth :assumption, :refs nil} {:plid 13, :body (at [i'] (finally A)), :roth :assumption, :refs nil} {:plid 16, :body (<= i i'), :roth :succ/<=, :refs [12]} [{:plid 17, :body (<= i' j), :roth :assumption, :refs nil} {:plid 18, :body (at [j] A), :roth :assumption, :refs nil} {:plid 21, :body (<= i j), :roth :<=trans, :refs [16 17]} {:plid 22, :body (at [i] (finally A)), :roth :finally-i, :refs [18 21]}] {:plid 15, :body (at [i] (finally A)), :roth :finally-e, :refs [13 [17 22]]}] {:plid 9, :body (at [i] (finally A)), :roth :atnext-e, :refs [7 [12 15]]}] {:plid 2, :body (at [i] (finally A)), :roth :or-e, :refs [1 [4 11] [7 9]]}]}
{:id :always-impl->impl-atnext, :given [(at [i] (always (impl A B)))], :conclusion [(at [i] (impl (atnext A) (atnext B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (impl A B)))} [{:plid 4, :body (at [i] (atnext A)), :roth :assumption, :refs nil} [{:plid 7, :body (succ i i'), :roth :assumption, :refs nil} {:plid 8, :body (at [i'] A), :roth :assumption, :refs nil} {:plid 11, :body (<= i i'), :roth :succ/<=, :refs [7]} {:plid 12, :body (at [i'] (impl A B)), :roth :always-e, :refs [1 11]} {:plid 13, :body (at [i'] B), :roth :impl-e, :refs [12 8]} {:plid 14, :body (at [i] (atnext B)), :roth :atnext-i, :refs [13 7]}] {:plid 6, :body (at [i] (atnext B)), :roth :atnext-e, :refs [4 [7 14]]}] {:plid 2, :body (at [i] (impl (atnext A) (atnext B))), :roth :impl-i, :refs [[4 6]]}]}
{:id :always-impl->impl-finally, :given [(at [i] (always (impl A B)))], :conclusion [(at [i] (impl (finally A) (finally B)))], :proof [{:plid 1, :roth :premise, :body (at [i] (always (impl A B)))} [{:plid 4, :body (at [i] (finally A)), :roth :assumption, :refs nil} [{:plid 7, :body (<= i j), :roth :assumption, :refs nil} {:plid 8, :body (at [j] A), :roth :assumption, :refs nil} {:plid 11, :body (at [j] (impl A B)), :roth :always-e, :refs [1 7]} {:plid 12, :body (at [j] B), :roth :impl-e, :refs [11 8]} {:plid 13, :body (at [i] (finally B)), :roth :finally-i, :refs [12 7]}] {:plid 6, :body (at [i] (finally B)), :roth :finally-e, :refs [4 [7 13]]}] {:plid 2, :body (at [i] (impl (finally A) (finally B))), :roth :impl-i, :refs [[4 6]]}]}
{:id :always-expansion, :given [(at [i] (always A))], :conclusion [(at [i] (and A (and (atnext A) (atnext (always A)))))], :proof [{:plid 1, :roth :premise, :body (at [i] (always A))} {:plid 4, :body (at [i] A), :roth :always->current, :refs [1]} {:plid 5, :body (at [i] (atnext A)), :roth :always->atnext, :refs [1]} {:plid 6, :body (succ i i'), :roth :succ, :refs []} [{:plid 12, :body (<= i' j), :roth :assumption, :refs nil} {:plid 15, :body (<= i i'), :roth :succ/<=, :refs [6]} {:plid 16, :body (<= i j), :roth :<=trans, :refs [15 12]} {:plid 17, :body (at [j] A), :roth :always-e, :refs [1 16]}] {:plid 11, :body (at [i'] (always A)), :roth :always-i, :refs [[12 17]]} {:plid 7, :body (at [i] (atnext (always A))), :roth :atnext-i, :refs [11 6]} {:plid 9, :body (at [i] (and (atnext A) (atnext (always A)))), :roth :and-i, :refs [5 7]} {:plid 10, :body (at [i] (and A (and (atnext A) (atnext (always A))))), :roth :and-i, :refs [4 9]}]}
{:id :linearity1, :given [(at [i] (atnext A))], :conclusion [(at [i] (not (atnext (not A))))], :proof [{:plid 1, :roth :premise, :body (at [i] (atnext A))} [{:plid 4, :body (at [i] (atnext (not A))), :roth :assumption, :refs nil} {:plid 7, :body (at [i] (not (atnext A))), :roth :atnext-not->not-atnext, :refs [4]} {:plid 8, :body (at [i] contradiction), :roth :not-e, :refs [7 1]}] {:plid 2, :body (at [i] (not (atnext (not A)))), :roth :not-i, :refs [[4 8]]}]}
{:id :linearity2, :given [(at [i] (not (atnext (not A))))], :conclusion [(at [i] (atnext A))], :proof [{:plid 1, :roth :premise, :body (at [i] (not (atnext (not A))))} {:plid 4, :body (at [i] (atnext (not (not A)))), :roth :not-atnext->atnext-not, :refs [1]} [{:plid 5, :body (succ i i'), :roth :assumption, :refs nil} {:plid 6, :body (at [i'] (not (not A))), :roth :assumption, :refs nil} {:plid 9, :body (at [i'] A), :roth :notnot-e, :refs [6]} {:plid 8, :body (at [i] (atnext A)), :roth :atnext-i, :refs [9 5]}] {:plid 2, :body (at [i] (atnext A)), :roth :atnext-e, :refs [4 [5 8]]}]}
{:id :until->finally, :given [(at [i] (until A B))], :conclusion [(at [i] (finally B))], :proof [{:plid 1, :roth :premise, :body (at [i] (until A B))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 5, :body (at [j] B), :roth :assumption, :refs nil} {:plid 12, :body (<= j j), :roth :<=refl, :refs []} {:plid 13, :body (at [j] (finally B)), :roth :finally-i, :refs [5 12]}] [{:plid 8, :body (<= i j), :roth :assumption, :refs nil} {:plid 9, :body (at [j] (and A (atnext (finally B)))), :roth :assumption, :refs nil} {:plid 14, :body (at [j] (atnext (finally B))), :roth :and-e2, :refs [9]} [{:plid 15, :body (succ j j'), :roth :assumption, :refs nil} {:plid 16, :body (at [j'] (finally B)), :roth :assumption, :refs nil} [{:plid 19, :body (<= j' k), :roth :assumption, :refs nil} {:plid 20, :body (at [k] B), :roth :assumption, :refs nil} {:plid 23, :body (<= j j'), :roth :succ/<=, :refs [15]} {:plid 24, :body (<= j k), :roth :<=trans, :refs [23 19]} {:plid 25, :body (at [j] (finally B)), :roth :finally-i, :refs [20 24]}] {:plid 18, :body (at [j] (finally B)), :roth :finally-e, :refs [16 [19 25]]}] {:plid 11, :body (at [j] (finally B)), :roth :atnext-e, :refs [14 [15 18]]}] {:plid 2, :body (at [i] (finally B)), :roth :until-e, :refs [1 [4 13] [8 11]]}]}
{:id :until-expansion1, :given [(at [i] (or B (and A (atnext (until A B)))))], :conclusion [(at [i] (until A B))], :proof [{:plid 1, :roth :premise, :body (at [i] (or B (and A (atnext (until A B)))))} [{:plid 4, :body (at [i] B), :roth :assumption, :refs nil} {:plid 10, :body (at [i] (until A B)), :roth :until-i1, :refs [4]}] [{:plid 7, :body (at [i] (and A (atnext (until A B)))), :roth :assumption, :refs nil} {:plid 11, :body (at [i] A), :roth :and-e1, :refs [7]} {:plid 12, :body (at [i] (atnext (until A B))), :roth :and-e2, :refs [7]} {:plid 13, :body (at [i] (until A B)), :roth :until-i2, :refs [11 12]}] {:plid 2, :body (at [i] (until A B)), :roth :or-e, :refs [1 [4 10] [7 13]]}]}
{:id :until-expansion2, :given [(at [i] (until A B))], :conclusion [(at [i] (or B (and A (atnext (until A B)))))], :proof [{:plid 1, :roth :premise, :body (at [i] (until A B))} [{:plid 4, :body (<= i j), :roth :assumption, :refs nil} {:plid 5, :body (at [j] B), :roth :assumption, :refs nil} {:plid 7, :body (at [j] (or B (and A (atnext (until A B))))), :roth :or-i1, :refs [5]}] [{:plid 8, :body (<= i j), :roth :assumption, :refs nil} {:plid 9, :body (at [j] (and A (atnext (or B (and A (atnext (until A B))))))), :roth :assumption, :refs nil} {:plid 13, :body (at [j] (atnext (or B (and A (atnext (until A B)))))), :roth :and-e2, :refs [9]} {:plid 14, :body (at [j] A), :roth :and-e1, :refs [9]} [{:plid 15, :body (succ j j'), :roth :assumption, :refs nil} {:plid 16, :body (at [j'] (or B (and A (atnext (until A B))))), :roth :assumption, :refs nil} {:plid 19, :body (at [j'] (until A B)), :roth :until-expansion1, :refs [16]} {:plid 20, :body (at [j] (atnext (until A B))), :roth :atnext-i, :refs [19 15]} {:plid 21, :body (at [j] (and A (atnext (until A B)))), :roth :and-i, :refs [14 20]} {:plid 18, :body (at [j] (or B (and A (atnext (until A B))))), :roth :or-i2, :refs [21]}] {:plid 11, :body (at [j] (or B (and A (atnext (until A B))))), :roth :atnext-e, :refs [13 [15 18]]}] {:plid 2, :body (at [i] (or B (and A (atnext (until A B))))), :roth :until-e, :refs [1 [4 7] [8 11]]}]}
